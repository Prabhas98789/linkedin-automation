<!DOCTYPE html>
<html lang="en" class="bg-gray-50">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Messages</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
</head>
<body x-data="messagePage()" x-init="initPage()" class="min-h-screen text-gray-800 font-sans">
  <div class="flex h-screen">
    <!-- Sidebar -->
    <div class="w-1/4 border-r border-gray-200 bg-white overflow-y-auto flex flex-col">
      <a :href="`profile.html?uid=${uid}&user_id=${userId}`" class="text-blue-600 text-sm px-4 pt-3 hover:underline">‚Üê Back to Profile</a>
      <h2 class="text-xl font-semibold p-4 border-b">Connections</h2>
      <div class="px-4 pb-2">
        <input type="text" x-model="searchText" @keydown.enter="applyFilter" placeholder="Search..." class="w-full px-3 py-2 border rounded text-sm" />
        <button @click="applyFilter" class="mt-2 text-sm text-blue-600 hover:underline">Search</button>
        <button @click="clearFilter" class="mt-1 text-xs text-gray-400 hover:underline">Clear</button>
      </div>
      <ul class="flex-1 overflow-y-auto">
        <template x-for="person in paginatedPeople" :key="person.connection_urn">
          <li @click="selectConnection(person)" class="cursor-pointer hover:bg-gray-100 px-4 py-3 flex items-center gap-3" :class="{ 'bg-gray-200': selectedConnection?.connection_urn === person.connection_urn }">
            <img :src="clean(person.profile_picture_url)" class="w-8 h-8 rounded-full object-cover" />
            <span x-text="`${clean(person.first_name)} ${clean(person.last_name)}`" class="text-sm font-medium"></span>
          </li>
        </template>
      </ul>
      <div class="px-4 py-3 flex flex-wrap justify-center gap-2" x-show="totalPages > 1">
        <button @click="goToPage(currentPage - 1)" :disabled="currentPage === 1" class="px-2 py-1 border rounded text-sm" :class="currentPage === 1 ? 'bg-gray-200 text-gray-500' : 'bg-white hover:bg-gray-100'">Prev</button>
        <template x-for="page in pagesToShow()" :key="page">
          <template x-if="page === '...'"><span class="px-2 py-1 text-gray-500">...</span></template>
          <template x-if="page !== '...'"><button @click="goToPage(page)" class="px-2 py-1 border rounded text-sm" :class="page === currentPage ? 'bg-gray-300 text-black' : 'bg-white hover:bg-gray-100'"><span x-text="page"></span></button></template>
        </template>
        <button @click="goToPage(currentPage + 1)" :disabled="currentPage === totalPages" class="px-2 py-1 border rounded text-sm" :class="currentPage === totalPages ? 'bg-gray-200 text-gray-500' : 'bg-white hover:bg-gray-100'">Next</button>
      </div>
    </div>

    <!-- Chat Panel -->
    <div class="flex-1 flex flex-col">
      <div class="px-6 py-4 border-b flex items-center justify-between bg-white">
        <div class="flex items-center gap-4">
          <template x-if="selectedConnection">
            <div class="flex items-center gap-4">
              <img :src="clean(selectedConnection.profile_picture_url)" class="w-10 h-10 rounded-full object-cover" />
              <div>
                <div class="text-lg font-semibold" x-text="`${clean(selectedConnection.first_name)} ${clean(selectedConnection.last_name)}`"></div>
                <div class="text-sm text-gray-500" x-text="clean(selectedConnection.headline)"></div>
              </div>
            </div>
          </template>
          <template x-if="!selectedConnection">
            <div class="text-gray-400 text-sm">Select a connection to start chatting</div>
          </template>
        </div>
        <div class="flex items-center gap-4">
          <label class="flex items-center gap-2 text-sm">
            <input type="checkbox" x-model="aiMode" class="form-checkbox" />
            AI Mode
          </label>
          <button @click="askAI" class="bg-blue-600 text-white text-sm px-3 py-1 rounded hover:bg-blue-700">Ask AI</button>
        </div>
      </div>

      <div class="flex-1 overflow-y-auto p-6 space-y-4 bg-gray-50">
        <template x-for="msg in chatMessages" :key="msg.message_id || msg.id">
          <div class="max-w-lg" :class="msg.is_sender ? 'ml-auto text-right' : 'mr-auto text-left'">
            <div class="inline-block px-4 py-2 rounded-lg bg-gray-200 text-gray-800" :class="msg.is_sender ? 'rounded-tr-none' : 'rounded-tl-none'">
              <span x-text="msg.text"></span>
            </div>
            <div class="text-xs text-gray-400 mt-1" x-text="new Date(msg.timestamp).toLocaleString()"></div>
          </div>
        </template>
      </div>

      <div class="p-4 border-t bg-white flex gap-2">
        <input x-model="newMessage" @keydown.enter="sendMessage" type="text" placeholder="Type a message..." class="flex-1 px-4 py-2 border rounded-lg text-sm" />
        <button @click="sendMessage" class="bg-gray-700 text-white px-4 py-2 rounded hover:bg-gray-800 text-sm">Send</button>
      </div>
    </div>
  </div>

  <script>
    function escapeHtml(unsafe) {
      return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/'/g, "&#039;");
    }

    function messagePage() {
      return {
        uid: '', userId: '', aiMode: false,
        people: [], paginatedPeople: [], searchText: '',
        currentPage: 1, itemsPerPage: 10, totalPages: 1,
        selectedConnection: null, chatMessages: [], newMessage: '',

        async initPage() {
          const params = new URLSearchParams(window.location.search);
          this.uid = params.get('uid');
          this.userId = params.get('user_id');
          if (!this.uid || !this.userId) return alert('Missing uid or user_id'), window.location.href = 'auth.html';
          await this.fetchConnections(1);
          if (this.paginatedPeople.length > 0) this.selectConnection(this.paginatedPeople[0]);
        },

        async fetchConnections(page = 1) {
          const seen = new Set(); const cleaned = []; const desired = this.itemsPerPage;
          let offset = (page - 1) * desired;
          while (cleaned.length < desired) {
            const url = `https://n8n.sapidblue.in/webhook/Get-first-connection-list?account_id=${this.uid}&user_id=${this.userId}&offset=${offset}&limit=${desired + 10}&filter_text=${encodeURIComponent(this.searchText)}`;
            const res = await fetch(url); const data = await res.json();
            if (!Array.isArray(data) || data.length === 0) break;
            for (const item of data) {
              const obj = this.cleanObject(item);
              if (!seen.has(obj.member_id)) seen.add(obj.member_id), cleaned.push(obj);
              if (cleaned.length >= desired) break;
            }
            offset += desired + 10;
          }
          this.paginatedPeople = cleaned; this.people = cleaned;
          const total = parseInt(this.clean(cleaned[0]?.total_count)) || (page * desired);
          this.totalPages = Math.max(1, Math.ceil(total / desired));
          this.currentPage = page;
        },

        async selectConnection(person) {
          this.selectedConnection = person;
          await fetch('https://n8n.sapidblue.in/webhook/message-sync-user', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ account_id: this.uid, user_id: this.userId, member_id: person.member_id })
          });
          await this.fetchMessages(person.connection_urn);
        },

        async fetchMessages(connectionUrn) {
          try {
            const res = await fetch(`https://n8n.sapidblue.in/webhook/prev-messgae?uid=${this.uid}&user_id=${this.userId}&connection_urn=${encodeURIComponent(connectionUrn)}`);
            const data = await res.json();
            this.chatMessages = Array.isArray(data) ? data : [];
          } catch (err) {
            this.chatMessages = []; console.error("Fetch messages error:", err);
          }
        },

        async sendMessage() {
          if (!this.newMessage.trim() || !this.selectedConnection) return;
          const messageText = escapeHtml(this.newMessage.trim());
          await fetch('https://n8n.sapidblue.in/webhook/send-message-go', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ uid: this.uid, user_id: this.userId, connection_urn: this.selectedConnection.connection_urn, message: messageText })
          });
          this.chatMessages.push({ text: messageText, is_sender: true, timestamp: new Date().toISOString() });
          if (this.aiMode) this.triggerAutoReply();
          this.newMessage = '';
        },

        async triggerAutoReply() {
          await fetch('https://n8n.sapidblue.in/webhook/auto-reply-api', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ uid: this.uid, user_id: this.userId, connection_urn: this.selectedConnection.connection_urn })
          });
        },

        async askAI() {
          const res = await fetch('https://n8n.sapidblue.in/webhook/ask-ai-api', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ uid: this.uid, user_id: this.userId, connection_urn: this.selectedConnection.connection_urn })
          });
          const data = await res.json();
          if (data?.suggestion) this.newMessage = data.suggestion;
        },

        applyFilter() { this.fetchConnections(1); },
        clearFilter() { this.searchText = ''; this.fetchConnections(1); },
        goToPage(p) { if (p >= 1 && p <= this.totalPages) this.fetchConnections(p); },
        pagesToShow() {
          const pages = [], range = 2;
          if (this.totalPages <= 7) return Array.from({ length: this.totalPages }, (_, i) => i + 1);
          pages.push(1);
          if (this.currentPage > range + 2) pages.push('...');
          for (let i = this.currentPage - range; i <= this.currentPage + range; i++)
            if (i > 1 && i < this.totalPages) pages.push(i);
          if (this.currentPage < this.totalPages - range - 1) pages.push('...');
          pages.push(this.totalPages);
          return pages;
        },
        clean(v) { return typeof v === 'string' ? v.replace(/^"+|"+$/g, '').trim() : (v || ''); },
        cleanObject(o) { const r = {}; for (const k in o) r[k] = this.clean(o[k]); return r; }
      };
    }
  </script>
</body>
</html>
